'use' is used to import modules, crates, functions etc from other files or libraries
std -> it is standard library which comes with rust installation
example ->
use std::io; // importing io module from standard library for input output operations

cmd: cargo add -> it is used to add dependencies to Cargo.toml file [library crates]
cmd: cargo doc --open // this will open rust doc in browser

Variables -> let used to create variables 
variables are immutable in rust
let a = 32; 
but we can make them mutable by adding 'mut' keyword
let mut a = 32;

also we can make variable using const but this will never change, but we have to give type in case of const, in case of let it default gives a type i32
const a: u8 = 32;

const can be declared in any scope where local or global, but in case of let it is only local scope

there are different data types in rust
1. Scalar types -> represents a single value
  a. Integer types -> i8, i16, i32, i64, i128, isize (signed integers)
                     u8, u16, u32, u64, u128, usize (unsigned integers)
  b. Floating point types -> f32, f64
  c. Boolean type -> bool (true or false)
  d. Character type -> char (represents a single Unicode scalar value)
2. Compound types -> represents multiple values
    a. Tuple type -> can group multiple values of different types into a single compound type
    b. Array type -> can group multiple values of the same type into a single compound type
    c. Slice type -> dynamically sized view into a contiguous sequence of elements
    d. Struct type -> custom data type that lets you name and package together multiple related values


Shadowing -> we can declare a new variable with the same name as a previous variable, this is called shadowing
eg: let x = 4;
    let x = 3; // x is now 3

Data Binding -> when we create a variable using let, we are binding a name to a value
eg: let x = 5; // here x is bound to value 5

Panicing -> when the program encounters an unrecoverable error, it will panic and terminate the program, accessing in debug mode, not in release mode
eg: let a = [1, 2, 3];
     println!("{}", a[5]); // this will cause panic at runtime
    let b:u8 = 256; // this will cause panic at compile time as u8 can only hold values from 0 to 255


functions -> declared using fn keyword
- we can create functions before or after main function
- name convention is snake_case
- parameters must have type specified
- return type is specified after -> symbol
*- functions is an expression in rust
eg:
fn add(a: i32, b: i32) -> i32 {
    a + b // no need to use return keyword, last expression is returned, can also use return keyword with semicolon
}

statements -> are instructions that perform some action and do not return a value
expressions -> are instructions that evaluate to a value


Control Flow
if condition {
    // code to execute if condition is true
} else {
    // code to execute if condition is false
}

- in rust if is an expression, so it can return a value
eg:
let number = 6;
let result = if number % 4 == 0 {
    "number is divisible by 4"
}else {
    "number is not divisible by 4"
}

Loops
1. loop -> infinite loop until break is called
eg:
let mut count = 0;
loop {
    count += 1;
    if count == 5 {
        break;
    }
}

2. while -> loop while condition is true
eg:
let mut number = 3;
while number != 0 {
    println!("{}", number);
    number -= 1;
}

3. for -> loop over a range or collection
eg:
for i in 1..5 { // 1 to 4
    println!("{}", i);
}

in rust loop has labels to break outer loops 'label_name: loop { }
eg:
'outer: loop {
    'inner: loop {
        break 'outer; // breaks outer loop
    }
} 

// reverse iteration
for i in (1..5).rev() {
    println!("{}", i); // prints 4 to 1
}
